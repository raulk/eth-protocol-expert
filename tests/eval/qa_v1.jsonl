{"question": "What is the base fee in EIP-1559 and what happens to it?", "expected_answer": "The base fee is a per-gas fee that is burned (destroyed by the protocol) rather than paid to miners. It adjusts up or down each block based on network congestion, increasing when blocks are above the gas target and decreasing when below.", "difficulty": "easy", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What are the two fee components in an EIP-1559 transaction?", "expected_answer": "EIP-1559 transactions have two fee components: max_priority_fee_per_gas (the tip paid to miners/validators) and max_fee_per_gas (the maximum total fee covering both the base fee and priority fee). Users pay the base fee plus the priority fee, but never more than max_fee_per_gas.", "difficulty": "easy", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What is the ELASTICITY_MULTIPLIER in EIP-1559 and what does it do?", "expected_answer": "The ELASTICITY_MULTIPLIER is set to 2 in EIP-1559. It allows blocks to be up to 2x the target size during periods of high demand. The gas_limit represents the maximum gas allowed, while the gas_target (gas_limit / ELASTICITY_MULTIPLIER) is the ideal amount.", "difficulty": "medium", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What is the BASE_FEE_MAX_CHANGE_DENOMINATOR in EIP-1559?", "expected_answer": "BASE_FEE_MAX_CHANGE_DENOMINATOR is set to 8 in EIP-1559. This limits how much the base fee can change between blocks to 1/8 (12.5%), making fee estimation more predictable.", "difficulty": "medium", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What transaction type number does EIP-1559 introduce?", "expected_answer": "EIP-1559 introduces transaction type 2 (0x02) as defined by EIP-2718. The transaction format is: 0x02 || rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit, destination, amount, data, access_list, signature_y_parity, signature_r, signature_s]).", "difficulty": "easy", "topic": "EIP-1559", "source_eips": [1559, 2718]}
{"question": "How does burning the base fee in EIP-1559 affect ETH supply?", "expected_answer": "Burning the base fee means ETH can become deflationary. If more ETH is burned in base fees than issued through block rewards, total ETH supply decreases. This creates economic value for ETH holders and reduces risks associated with miner extractable value (MEV).", "difficulty": "medium", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What happens to legacy transactions under EIP-1559?", "expected_answer": "Legacy transactions continue to work under EIP-1559 but don't directly benefit from the new pricing system. The legacy gas_price is treated as both max_fee_per_gas and max_priority_fee_per_gas, meaning the entire gas_price goes toward either base fee or priority fee.", "difficulty": "medium", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What is the effective_gas_price in EIP-1559?", "expected_answer": "The effective_gas_price is what the transaction sender actually pays per gas unit. It equals the base_fee_per_gas plus the priority_fee_per_gas, where the priority fee is capped at min(max_priority_fee_per_gas, max_fee_per_gas - base_fee_per_gas). This is what the GASPRICE opcode returns.", "difficulty": "hard", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "Why does EIP-1559 burn the base fee instead of giving it to miners?", "expected_answer": "Burning the base fee removes miner incentive to manipulate fees to extract more from users. It also ensures only ETH can be used to pay for transactions (cementing ETH's economic value) and counterbalances inflation while still rewarding miners with priority fees and block rewards.", "difficulty": "hard", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What is the initial base fee when EIP-1559 activates on a chain?", "expected_answer": "The INITIAL_BASE_FEE is set to 1,000,000,000 wei (1 gwei) at the fork block number. This provides a reasonable starting point from which the dynamic adjustment mechanism begins.", "difficulty": "medium", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "How does the base fee adjustment formula work in EIP-1559?", "expected_answer": "If parent block gas_used equals target, base fee stays the same. If above target, base fee increases by (parent_base_fee * gas_used_delta / parent_gas_target / 8), minimum 1 wei. If below target, it decreases by the same formula (but can go to 0). This creates predictable fee changes.", "difficulty": "hard", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What attack does EIP-1559 address regarding miners mining empty blocks?", "expected_answer": "EIP-1559 addresses the concern that miners might collude to mine empty blocks to drive the base fee to zero, then mine half-full blocks sorted by priority fee. This attack is unstable because any defecting miner earns more than participants, and executing it requires over 50% hashpower.", "difficulty": "hard", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What is a blob transaction in EIP-4844?", "expected_answer": "A blob transaction is a new EIP-2718 transaction type (type 0x03) that carries large amounts of data called 'blobs' which cannot be accessed by EVM execution. Only the blob commitments can be accessed. This provides cheap data availability for rollups.", "difficulty": "easy", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is the size of a single blob in EIP-4844?", "expected_answer": "A single blob contains FIELD_ELEMENTS_PER_BLOB (4096) field elements, each BYTES_PER_FIELD_ELEMENT (32) bytes, totaling 128 KB (131,072 bytes) per blob.", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What are the target and maximum blob counts per block in EIP-4844?", "expected_answer": "EIP-4844 targets 3 blobs (~0.375 MB) per block with TARGET_BLOB_GAS_PER_BLOCK of 393,216 gas, and allows maximum 6 blobs (~0.75 MB) with MAX_BLOB_GAS_PER_BLOCK of 786,432 gas. GAS_PER_BLOB is 2^17 (131,072).", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "How does blob gas pricing work in EIP-4844?", "expected_answer": "Blob gas is a separate gas type with its own EIP-1559-style base fee. The formula uses fake_exponential to approximate e^(excess_blob_gas / BLOB_BASE_FEE_UPDATE_FRACTION). MIN_BASE_FEE_PER_BLOB_GAS is 1 wei. The blob fee is burned, not refunded on failure.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is the BLOBHASH opcode in EIP-4844?", "expected_answer": "BLOBHASH (opcode 0x49) takes an index from the stack and returns the versioned hash of the blob at that index in the transaction, or zero if the index is out of bounds. It costs 3 gas (HASH_OPCODE_GAS).", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is the point evaluation precompile in EIP-4844?", "expected_answer": "The point evaluation precompile at address 0x0A verifies a KZG proof that a blob (via its commitment) evaluates to a specific value at a specific point. It costs 50,000 gas and returns FIELD_ELEMENTS_PER_BLOB and BLS_MODULUS for forward compatibility.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is a versioned hash in EIP-4844?", "expected_answer": "A versioned hash is a 32-byte commitment to a blob, created by taking SHA256 of the KZG commitment and replacing the first byte with VERSIONED_HASH_VERSION_KZG (0x01). This allows future upgrades to different commitment schemes while maintaining backwards compatibility.", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "How long must blob data be stored according to EIP-4844?", "expected_answer": "Blob data must be stored for MIN_EPOCHS_FOR_BLOB_SIDECARS_REQUESTS epochs, which is 4096 epochs (approximately 18 days). This is much shorter than execution payload history, reducing long-term storage burden.", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "Why can't blob transactions create contracts?", "expected_answer": "In blob transactions, the 'to' field MUST NOT be nil and must always represent a 20-byte address. This means blob transactions cannot have the form of a create transaction (where 'to' is null to indicate contract creation).", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What new header fields does EIP-4844 introduce?", "expected_answer": "EIP-4844 extends the block header with two new 64-bit unsigned integer fields: blob_gas_used (total blob gas consumed in the block) and excess_blob_gas (running total of blob gas consumed above target, used to calculate the blob base fee).", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "How do rollups benefit from EIP-4844?", "expected_answer": "Rollups can post data to blobs instead of calldata, which is much cheaper because blob space has its own fee market and blobs don't need permanent storage. Optimistic rollups use point evaluation for fraud proofs, while ZK rollups prove equivalence between blob and ZK commitments.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is the relationship between EIP-4844 and full danksharding?", "expected_answer": "EIP-4844 (proto-danksharding) introduces the same transaction format that will be used in full sharding, but blobs are not actually sharded. All consensus nodes download all blobs. Full sharding will add data availability sampling, allowing ~16 MB per block with only partial downloads.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "How does EIP-4844 handle blob transaction propagation in the mempool?", "expected_answer": "Blob transactions are NOT automatically broadcast to peers. They are only announced via NewPooledTransactionHashes messages and must be manually requested via GetPooledTransactions. This gives nodes control over throughput to prevent DoS from large blob data.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is the main interface defined by ERC-721?", "expected_answer": "ERC-721 defines the Non-Fungible Token Standard interface including balanceOf, ownerOf, safeTransferFrom, transferFrom, approve, setApprovalForAll, getApproved, and isApprovedForAll functions. Each token has a unique tokenId.", "difficulty": "easy", "topic": "NFT Standards", "source_eips": [721]}
{"question": "What is the difference between ERC-721 and ERC-1155?", "expected_answer": "ERC-721 is for non-fungible tokens where each token is unique (one tokenId = one item). ERC-1155 is a multi-token standard supporting both fungible and non-fungible tokens in a single contract, with balances tracked per tokenId per address, enabling efficient batch transfers.", "difficulty": "medium", "topic": "NFT Standards", "source_eips": [721, 1155]}
{"question": "What is safeTransferFrom in ERC-721?", "expected_answer": "safeTransferFrom is a transfer function that checks if the recipient is a contract, and if so, calls onERC721Received on the recipient. If the recipient doesn't implement this interface or returns an unexpected value, the transfer reverts. This prevents tokens from being locked in contracts that can't handle them.", "difficulty": "medium", "topic": "NFT Standards", "source_eips": [721]}
{"question": "What is the ERC-1155 TransferSingle event?", "expected_answer": "TransferSingle is emitted when a single token type is transferred. It includes operator (who initiated), from, to, id (token type), and value (amount). ERC-1155 also has TransferBatch for multiple token types in one transaction.", "difficulty": "medium", "topic": "NFT Standards", "source_eips": [1155]}
{"question": "What is ERC-1155 batch transfer capability?", "expected_answer": "ERC-1155 includes safeBatchTransferFrom which can transfer multiple token types (ids) with corresponding amounts (values) in a single transaction. This is more gas efficient than multiple ERC-721 transfers and useful for gaming/marketplace scenarios.", "difficulty": "medium", "topic": "NFT Standards", "source_eips": [1155]}
{"question": "What problem does EIP-2718 solve?", "expected_answer": "EIP-2718 introduces typed transaction envelopes to solve backwards compatibility issues. Previously, new transaction types had to be distinguishable by encoded payload alone. With EIP-2718, transactions are prefixed with a type byte, making it easy to add new transaction types without collision.", "difficulty": "medium", "topic": "Transaction Types", "source_eips": [2718]}
{"question": "How are typed transactions formatted according to EIP-2718?", "expected_answer": "Typed transactions are formatted as TransactionType || TransactionPayload, where TransactionType is a single byte between 0x00 and 0x7f, and TransactionPayload is opaque bytes defined by each transaction type. Legacy transactions start with bytes >= 0xc0 (RLP list), allowing differentiation.", "difficulty": "medium", "topic": "Transaction Types", "source_eips": [2718]}
{"question": "What is an access list in EIP-2930?", "expected_answer": "An access list is a list of addresses and storage keys that a transaction plans to access. It's included in type 1 transactions (0x01). Addresses and keys in the list are 'pre-warmed' and cost less to access (already in accessed_addresses/accessed_storage_keys sets from EIP-2929).", "difficulty": "medium", "topic": "Transaction Types", "source_eips": [2930]}
{"question": "What are the gas costs for access list entries in EIP-2930?", "expected_answer": "ACCESS_LIST_ADDRESS_COST is 2400 gas per address and ACCESS_LIST_STORAGE_KEY_COST is 1900 gas per storage key. These costs are charged upfront at transaction start. Accesses within the list then cost the 'warm' price (100 gas for SLOAD) rather than cold price.", "difficulty": "hard", "topic": "Transaction Types", "source_eips": [2930]}
{"question": "Why does EIP-2930 allow duplicate entries in access lists?", "expected_answer": "Duplicates are allowed for simplicity - avoiding complex rules about what counts as a duplicate (between list entries, vs sender/recipient, vs newly created contracts). Since gas is charged per item, duplicates only cost the sender more with no benefit, discouraging them naturally.", "difficulty": "hard", "topic": "Transaction Types", "source_eips": [2930]}
{"question": "What are AUTH and AUTHCALL opcodes in EIP-3074?", "expected_answer": "AUTH (0xf6) verifies an ECDSA signature and sets the 'authorized' context variable to allow an EOA to delegate control to a contract. AUTHCALL (0xf7) is like CALL but uses the authorized address as the caller. This enables sponsored transactions and EOA batching.", "difficulty": "hard", "topic": "Account Abstraction", "source_eips": [3074]}
{"question": "What happened to EIP-3074?", "expected_answer": "EIP-3074 was withdrawn and superseded by EIP-7702. The withdrawal reason was that EIP-7702 provides a better approach to account abstraction that is more compatible with the broader account abstraction roadmap.", "difficulty": "medium", "topic": "Account Abstraction", "source_eips": [3074]}
{"question": "What is the TERMINAL_TOTAL_DIFFICULTY in EIP-3675?", "expected_answer": "TERMINAL_TOTAL_DIFFICULTY is the accumulated difficulty threshold that triggers the Proof-of-Stake upgrade. For Ethereum Mainnet, it was set to 58,750,000,000,000,000,000,000. When a PoW block reaches this difficulty, it becomes a terminal PoW block.", "difficulty": "medium", "topic": "PoS Merge", "source_eips": [3675]}
{"question": "What is the TRANSITION_BLOCK in EIP-3675?", "expected_answer": "TRANSITION_BLOCK is the first PoS block of the canonical chain - the earliest PoS block (lowest block height). It must be a child of a terminal PoW block (one that reaches TERMINAL_TOTAL_DIFFICULTY while its parent is below it).", "difficulty": "medium", "topic": "PoS Merge", "source_eips": [3675]}
{"question": "What block fields become constants after the Merge (EIP-3675)?", "expected_answer": "After TRANSITION_BLOCK: ommersHash becomes keccak256(RLP([])), difficulty becomes 0, mixHash becomes 32 zero bytes, nonce becomes 8 zero bytes, and ommers list becomes empty. The extraData field is limited to 32 bytes maximum.", "difficulty": "hard", "topic": "PoS Merge", "source_eips": [3675]}
{"question": "What happens to block rewards after the Merge?", "expected_answer": "Block and ommer rewards are deprecated after EIP-3675. No balance increase for the beneficiary from block rewards, ommer inclusion rewards, or ommer block rewards. Transaction fee mechanics (priority fees to block producer) remain unchanged. Validator rewards come from the beacon chain.", "difficulty": "medium", "topic": "PoS Merge", "source_eips": [3675]}
{"question": "What is the new fork choice rule after EIP-3675?", "expected_answer": "After the first POS_FORKCHOICE_UPDATED event, the PoW heaviest chain rule is replaced with PoS LMD-GHOST (Latest Message Driven Greedy Heaviest Observed Sub-Tree). The head and finalized blocks are set according to POS_FORKCHOICE_UPDATED events from the beacon chain.", "difficulty": "hard", "topic": "PoS Merge", "source_eips": [3675]}
{"question": "Why does EIP-3675 use total difficulty instead of block number for triggering the upgrade?", "expected_answer": "Using block number is unsafe because an attacker with minority hashpower could build a malicious fork satisfying the block height requirement. The first PoS block could then be proposed on this adversarial fork. Total difficulty requires accumulated work, making such attacks economically infeasible.", "difficulty": "hard", "topic": "PoS Merge", "source_eips": [3675]}
{"question": "What is EIP-4895 about?", "expected_answer": "EIP-4895 introduces beacon chain push withdrawals as system-level operations. Validator withdrawals from the beacon chain create unconditional balance increases to recipient addresses. These are processed after user transactions, have no gas costs, and cannot fail.", "difficulty": "medium", "topic": "PoS Merge", "source_eips": [4895]}
{"question": "What fields does a withdrawal object contain in EIP-4895?", "expected_answer": "A withdrawal contains: index (uint64, monotonically increasing global counter), validator_index (uint64, the validator on consensus layer), address (20 bytes, recipient), and amount (uint64, ether in Gwei). Withdrawals are RLP serialized as [index, validator_index, address, amount].", "difficulty": "medium", "topic": "PoS Merge", "source_eips": [4895]}
{"question": "What does EIP-155 provide?", "expected_answer": "EIP-155 provides simple replay attack protection by including the chain ID in transaction signatures. The signing hash includes chainid, 0, 0 as additional elements, and the v value encodes the chain ID. This prevents transactions from being replayed on other chains like Ethereum Classic.", "difficulty": "easy", "topic": "General Protocol", "source_eips": [155]}
{"question": "What is the chain ID for Ethereum mainnet according to EIP-155?", "expected_answer": "Ethereum mainnet has chain ID 1. Other examples: Ropsten was 3, Rinkeby was 4, Goerli is 5, Kovan was 42, and Geth private chains default to 1337.", "difficulty": "easy", "topic": "General Protocol", "source_eips": [155]}
{"question": "How does the v value encode chain ID in EIP-155 signatures?", "expected_answer": "For EIP-155 signatures, v is set to {0,1} + CHAIN_ID * 2 + 35, where {0,1} is the parity of the y-value of the signature curve point. For mainnet (chain ID 1), v is either 37 or 38. Legacy signatures without chain ID use v = 27 or 28.", "difficulty": "hard", "topic": "General Protocol", "source_eips": [155]}
{"question": "What is the London hard fork and which EIPs were included?", "expected_answer": "The London hard fork activated on Ethereum mainnet on August 5, 2021 at block 12,965,000. It included EIP-1559 (fee market changes), EIP-3198 (BASEFEE opcode), EIP-3529 (reduced gas refunds), EIP-3541 (reject 0xEF prefix contracts), and EIP-3554 (difficulty bomb delay).", "difficulty": "medium", "topic": "General Protocol", "source_eips": [1559]}
{"question": "What is the Dencun hard fork?", "expected_answer": "Dencun (Deneb + Cancun) activated in March 2024 and included EIP-4844 (proto-danksharding with blob transactions), EIP-4788 (beacon block root in EVM), EIP-1153 (transient storage), EIP-5656 (MCOPY), EIP-6780 (SELFDESTRUCT changes), and EIP-7516 (BLOBBASEFEE opcode).", "difficulty": "medium", "topic": "General Protocol", "source_eips": [4844]}
{"question": "What was The Merge?", "expected_answer": "The Merge was Ethereum's transition from Proof-of-Work to Proof-of-Stake consensus on September 15, 2022. It was triggered by TERMINAL_TOTAL_DIFFICULTY of 58,750,000,000,000,000,000,000 and connected the execution layer to the beacon chain which had been running since December 2020.", "difficulty": "easy", "topic": "General Protocol", "source_eips": [3675]}
{"question": "How do EIP-1559, EIP-2718, and EIP-2930 relate to each other?", "expected_answer": "EIP-2718 defines the typed transaction envelope format. EIP-2930 uses this to define type 1 transactions with access lists. EIP-1559 uses it for type 2 transactions with the new fee market (max_fee and max_priority_fee). EIP-1559 requires both EIP-2718 and EIP-2930.", "difficulty": "hard", "topic": "General Protocol", "source_eips": [1559, 2718, 2930]}
{"question": "What is the difference between max_fee_per_gas and gas_price?", "expected_answer": "gas_price (legacy) is a single value representing both the maximum and actual fee per gas. max_fee_per_gas (EIP-1559) is the maximum total the sender will pay, but actual payment is base_fee + priority_fee which may be less. max_fee_per_gas provides fee predictability and potential refunds.", "difficulty": "medium", "topic": "General Protocol", "source_eips": [1559]}
{"question": "What happens to excess payment in EIP-1559 transactions?", "expected_answer": "If max_fee_per_gas exceeds the actual effective_gas_price (base_fee + priority_fee), the sender pays only the effective price for gas used. Unused gas is refunded at the effective_gas_price rate. The difference between max_fee and effective price is never charged.", "difficulty": "medium", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "How does EIP-4844 affect Ethereum's data availability?", "expected_answer": "EIP-4844 expands Ethereum's data availability by adding blob space separate from calldata. Blobs provide ~0.75 MB max per block for rollup data. This data is available for about 18 days, then can be pruned. It's a step toward full data sharding with ~16 MB per block.", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is the blob base fee update fraction in EIP-4844?", "expected_answer": "BLOB_BASE_FEE_UPDATE_FRACTION is 3,338,477. The base fee formula targets a maximum change rate of e^(TARGET_BLOB_GAS_PER_BLOCK / BLOB_BASE_FEE_UPDATE_FRACTION) which is approximately 1.125 (12.5%) per block, similar to EIP-1559's mechanism.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "Why are blob transactions not automatically broadcast in the mempool?", "expected_answer": "Blob transactions have large data (up to 768 KB with 6 blobs) which poses mempool DoS risks. By only announcing via NewPooledTransactionHashes, receiving nodes control which and how many transactions to fetch, allowing them to throttle throughput to acceptable levels.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is the GASPRICE opcode behavior after EIP-1559?", "expected_answer": "After EIP-1559, GASPRICE (0x3a) returns the effective_gas_price - the amount the signer pays per gas. This is base_fee_per_gas + priority_fee_per_gas. It no longer represents what the miner receives (which is just the priority fee since base fee is burned).", "difficulty": "hard", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What is KZG commitment in the context of EIP-4844?", "expected_answer": "KZG (Kate-Zaverucha-Goldberg) commitment is a polynomial commitment scheme used in EIP-4844. Each blob has a 48-byte KZGCommitment that cryptographically commits to its contents. The point evaluation precompile can verify that a blob evaluates to a specific value at a specific point.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "How does EIP-2930 help with contract breakage from EIP-2929?", "expected_answer": "EIP-2929 increased gas costs for cold storage access, potentially breaking contracts with hardcoded gas limits. EIP-2930 allows transactions to pre-specify addresses and storage keys to access, pre-warming them so actual execution only pays the cheap warm price (100 gas for SLOAD).", "difficulty": "hard", "topic": "Transaction Types", "source_eips": [2929, 2930]}
{"question": "What is the intrinsic gas cost formula for EIP-1559 transactions?", "expected_answer": "EIP-1559 transactions inherit costs from EIP-2930: 21000 base + 16 * non-zero calldata bytes + 4 * zero calldata bytes + 1900 * access list storage key count + 2400 * access list address count.", "difficulty": "hard", "topic": "EIP-1559", "source_eips": [1559, 2930]}
{"question": "What security consideration does EIP-2718 have for transaction type signatures?", "expected_answer": "EIP-2718 strongly recommends including the TransactionType as the first byte of signed data. Without this, a transaction might be signature-compatible with a different type, allowing signature reuse attacks across transaction types.", "difficulty": "hard", "topic": "Transaction Types", "source_eips": [2718]}
{"question": "What is the purpose of the commit field in EIP-3074 AUTH signatures?", "expected_answer": "The commit field is a 32-byte value in the AUTH signature that allows invoker contracts to implement arbitrary constraints. Users commit to specific call properties (nonces, values, targets) and the invoker verifies these match. This enables replay protection and call validation without enshrining it in the protocol.", "difficulty": "hard", "topic": "Account Abstraction", "source_eips": [3074]}
{"question": "Why can't EIP-3074 AUTH be used with contract accounts?", "expected_answer": "AUTH checks EXTCODESIZE of the authority address - if it's non-zero (account has code), the operation fails and authorized is unset. This follows EIP-3607's principle that accounts with both code and a known private key shouldn't make arbitrary calls.", "difficulty": "hard", "topic": "Account Abstraction", "source_eips": [3074]}
{"question": "What is the Shanghai upgrade and what did it enable?", "expected_answer": "The Shanghai upgrade (April 2023) enabled staked ETH withdrawals from the beacon chain via EIP-4895. It also included EIP-3651 (warm COINBASE), EIP-3855 (PUSH0), EIP-3860 (limit initcode size), and EIP-6049 (deprecate SELFDESTRUCT). Combined with consensus Capella upgrade.", "difficulty": "medium", "topic": "General Protocol", "source_eips": [4895]}
{"question": "How do withdrawals work after EIP-4895?", "expected_answer": "Withdrawals are system-level operations pushed from the beacon chain. They're processed after all user transactions, unconditionally increase recipient balances by the specified amount (in Gwei, converted to wei), have no gas cost, and cannot fail. Maximum withdrawals per block is bounded by consensus layer.", "difficulty": "medium", "topic": "PoS Merge", "source_eips": [4895]}
{"question": "What makes blob data different from calldata in Ethereum?", "expected_answer": "Blobs are not accessible by EVM execution (only their commitments/hashes are), have their own separate gas type and fee market, are stored in consensus layer sidecars rather than execution payloads, can be pruned after ~18 days, and are designed for rollup data availability rather than smart contract input.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is the BLS_MODULUS in EIP-4844?", "expected_answer": "BLS_MODULUS is 52435875175126190479447740508185965837690552500527637822603658699938581184513, the prime modulus of the BLS12-381 scalar field. Field elements in blobs must be less than this value. The point evaluation precompile returns this value for smart contract forward compatibility.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "How does EIP-1559 improve fee estimation for users?", "expected_answer": "EIP-1559 makes the base fee change by at most 12.5% per block, making it predictable. Wallets can auto-set fees by using the current base fee plus a small priority fee. Most users won't need to manually adjust fees, even during congestion, because max_fee handles temporary spikes.", "difficulty": "medium", "topic": "EIP-1559", "source_eips": [1559]}
{"question": "What happens if a blob transaction doesn't include at least one blob?", "expected_answer": "The transaction is invalid. EIP-4844 validation requires len(tx.blob_versioned_hashes) > 0 - there must be at least one blob. Additionally, all versioned hashes must start with VERSIONED_HASH_VERSION_KZG (0x01).", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What is the meaning of 'proto-danksharding' in EIP-4844?", "expected_answer": "Proto-danksharding refers to EIP-4844 implementing the transaction format and data structures planned for full danksharding, but without actual data sharding. All blobs are still fully downloaded by all nodes. It's a stepping stone that lets rollups benefit now while full sharding is developed.", "difficulty": "medium", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "What block validation rules changed after EIP-3675?", "expected_answer": "After the Merge: no verification of difficulty against the formula, no verification of nonce/mixHash against Ethash, no ommer list validation, but added verification that deprecated fields (ommersHash, difficulty, mixHash, nonce, ommers) are set to their constant values.", "difficulty": "hard", "topic": "PoS Merge", "source_eips": [3675]}
{"question": "Why does EIP-3675 keep the block format unchanged?", "expected_answer": "Keeping the block format backwards compatible helps existing smart contracts and services continue functioning. Contracts verifying Merkle proofs of transaction/receipt inclusion by validating block header hashes against BLOCKHASH can continue working without changes.", "difficulty": "medium", "topic": "PoS Merge", "source_eips": [3675]}
{"question": "What is the role of excess_blob_gas in EIP-4844?", "expected_answer": "excess_blob_gas is a header field tracking the running total of blob gas consumed above target. If parent's excess + used < target, excess is 0; otherwise it's parent's excess + used - target. This persistent data is used to calculate the blob base fee via the exponential formula.", "difficulty": "hard", "topic": "EIP-4844", "source_eips": [4844]}
{"question": "How does EIP-1559 affect blockchain stability concerns for chains with no block reward?", "expected_answer": "Without block rewards, chains relying only on transaction fees have instability issues - miners might mine 'sister blocks' to steal fees or engage in selfish mining. EIP-1559's burned base fee and separate priority fee partially address this by reducing fee variability and MEV incentives.", "difficulty": "hard", "topic": "EIP-1559", "source_eips": [1559]}
